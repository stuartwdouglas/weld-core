/*
 * JBoss, Home of Professional Open Source
 * Copyright 2008, Red Hat, Inc. and/or its affiliates, and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jboss.weld.bean.proxy;

import static org.jboss.invocation.proxy.ProxyFactory.CONSTRUCTED_GUARD;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

import javax.enterprise.inject.spi.Bean;

import org.jboss.classfilewriter.ClassMethod;
import org.jboss.classfilewriter.code.BranchEnd;
import org.jboss.classfilewriter.code.CodeAttribute;
import org.jboss.classfilewriter.code.ExceptionHandler;
import org.jboss.interceptor.proxy.LifecycleMixin;
import org.jboss.interceptor.util.proxy.TargetInstanceProxy;
import org.jboss.invocation.proxy.MethodBodyCreator;
import org.jboss.invocation.proxy.ProxyFactory;

/**
 * Proxy factory that generates client proxies, it uses optimizations that are
 * not valid for other proxy types.
 *
 * @author Stuart Douglas
 * @author Marius Bogoevici
 */
public class ClientProxyFactory<T> extends ProxyFactoryImpl<T>
{

   public final static String CLIENT_PROXY_SUFFIX = "ClientProxy";

   public ClientProxyFactory(Class<?> proxiedBeanType, Bean<?> bean)
   {
      this(proxiedBeanType, ProxyFactoryImpl.getProxyName(proxiedBeanType, bean), bean);
   }

   public ClientProxyFactory(Class<?> proxiedBeanType, String proxyName, Bean<?> bean)
   {
      super(ProxyFactoryImpl.proxyConfig(proxiedBeanType, proxyName, bean, CLIENT_PROXY_SUFFIX), bean);
   }

   protected void generateClass()
   {
      addInterface(super.getDefaultMethodOverride(), LifecycleMixin.class);
      addInterface(super.getDefaultMethodOverride(), TargetInstanceProxy.class);
      overrideEquals(new EqualsMethodBodyCreator());
      overrideHashcode(new HashCodeMethodBodyCreator());
      super.generateClass();
   };

   @Override
   public MethodBodyCreator getDefaultMethodOverride()
   {
      return new ForwardingMethodBodyCreator();
   }

   /**
    * Calls methodHandler.invoke with a null method parameter in order to get
    * the underlying instance. The invocation is then forwarded to this instance
    * with generated bytecode.
    * 
    */
   class ForwardingMethodBodyCreator extends ProxyFactory<T>.ProxyMethodBodyCreator
   {
      public void overrideMethod(ClassMethod method, Method superclassMethod)
      {
         final CodeAttribute ca = method.getCodeAttribute();
         // we can only use bytecode based invocation for some methods
         // at the moment we restrict it solely to public methods with public
         // return and parameter types
         boolean bytecodeInvocationAllowed = Modifier.isPublic(superclassMethod.getModifiers()) && Modifier.isPublic(superclassMethod.getReturnType().getModifiers());
         for (Class<?> paramType : superclassMethod.getParameterTypes())
         {
            if (!Modifier.isPublic(paramType.getModifiers()))
            {
               bytecodeInvocationAllowed = false;
               break;
            }
         }
         if (!bytecodeInvocationAllowed)
         {
            super.overrideMethod(method, superclassMethod);
            return;
         }
         // first we need to check the constructed field
         ca.aload(0);
         ca.getfield(getClassName(), CONSTRUCTED_GUARD, "Z");
         // if the object has not been constructed yet invoke the superclass
         // version of the method
         BranchEnd end = ca.ifne();
         ca.aload(0);
         ca.loadMethodParameters();
         ca.invokespecial(getSuperClassName(), method.getName(), method.getDescriptor());
         ca.returnInstruction();
         ca.branchEnd(end);
         // normal invocation path begins here
         // create a new interceptor invocation context whenever we invoke a
         // method on a client proxy
         // we use a try-catch block in order to make sure that
         // endInterceptorContext() is invoked regardless whether
         // the method has succeeded or not
         ExceptionHandler exceptionHandler = ca.exceptionBlockStart("java.lang.Exception");
         ca.invokestatic("org.jboss.weld.bean.proxy.InterceptionDecorationContext", "startInterceptorContext", "()V");

         ca.aload(0);
         ca.getfield(method.getClassFile().getName(), ProxyFactory.INVOCATION_HANDLER_FIELD, InvocationHandler.class);
         // pass null arguments to methodHandler.invoke
         ca.aload(0);
         ca.aconstNull();
         ca.aconstNull();

         // now we have all our arguments on the stack
         // lets invoke the method
         ca.invokeinterface(InvocationHandler.class.getName(), "invoke", "(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;");

         ca.checkcast(superclassMethod.getDeclaringClass());

         // now we should have the target bean instance on top of the stack
         // we need to dup it so we still have it to compare to the return value
         ca.dup();

         // lets create the method invocation
         String methodDescriptor = method.getDescriptor();
         ca.loadMethodParameters();
         if (superclassMethod.getDeclaringClass().isInterface())
         {
            ca.invokeinterface(superclassMethod.getDeclaringClass().getName(), superclassMethod.getName(), methodDescriptor);
         }
         else
         {
            ca.invokevirtual(superclassMethod.getDeclaringClass().getName(), superclassMethod.getName(), methodDescriptor);
         }

         // end the interceptor context, everything was fine
         ca.invokestatic("org.jboss.weld.bean.proxy.InterceptionDecorationContext", "endInterceptorContext", "()V");

         // jump over the catch block
         BranchEnd gotoEnd = ca.gotoInstruction();

         // create catch block
         ca.exceptionBlockEnd(exceptionHandler);
         ca.exceptionHandlerStart(exceptionHandler);
         ca.invokestatic("org.jboss.weld.bean.proxy.InterceptionDecorationContext", "endInterceptorContext", "()V");
         ca.athrow();

         // update the correct address to jump over the catch block
         ca.branchEnd(gotoEnd);

         // if this method returns a primitive we just return
         if (superclassMethod.getReturnType().isPrimitive())
         {
            ca.returnInstruction();
         }
         else
         {
            // otherwise we have to check that the proxy is not returning 'this;
            // now we need to check if the proxy has return 'this' and if so
            // return
            // an
            // instance of the proxy.
            // currently we have result, beanInstance on the stack.
            ca.dupX1();
            // now we have result, beanInstance, result
            // we need to compare result and beanInstance

            // first we need to build up the inner conditional that just returns
            // the
            // result
            BranchEnd returnInstruction = ca.ifAcmpeq();
            ca.returnInstruction();
            ca.branchEnd(returnInstruction);

            // now add the case where the proxy returns 'this';
            ca.aload(0);
            ca.checkcast(superclassMethod.getReturnType().getName());
            ca.returnInstruction();
         }
      }
   }

   /**
    * Client proxies use the following hashCode:
    * <code>MyProxyName.class.hashCode()</code>
    * 
    */
   class HashCodeMethodBodyCreator implements MethodBodyCreator
   {

      public void overrideMethod(ClassMethod method, Method superclassMethod)
      {
         final CodeAttribute ca = method.getCodeAttribute();
         ca.loadType(method.getClassFile().getName());
         // now we have the class object on top of the stack
         ca.invokevirtual("java.lang.Object", "hashCode", "()I");
         // now we have the hashCode
         ca.returnInstruction();
      }

   }

   /**
    * Client proxies are equal to other client proxies for the same bean.
    * <p>
    * The corresponding java code: <code>
          * return other instanceof MyProxyClassType.class
          * </code>
    * 
    */
   class EqualsMethodBodyCreator implements MethodBodyCreator
   {
      public void overrideMethod(ClassMethod method, Method superclassMethod)
      {
         final CodeAttribute ca = method.getCodeAttribute();
         ca.aload(1);
         ca.instanceofInstruction(method.getClassFile().getName());
         ca.returnInstruction();
      }
   }

}
